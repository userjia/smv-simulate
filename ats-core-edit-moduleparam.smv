--status:=[car_speed,car_angle,car_wheelAngle];
--ev:=[barrier,parallel,around,tar_x,tar_y,car_wheelAngle,car_speed];
--actuator:=[actuator_steerWheel.out,actuator_engine.out,actuator_brake.out,actuator_gear.out];
--can_in:=[sensor_speed.out,sensor_wheelAngle.out,sensor_GPS.out,sensor_campass.out];
--1 represent yes,have,is,right

--===================================main
MODULE main
	VAR
		si:Simulate(car);
		car:Car(ats.actuator);
		-- ?
		ats:ATS(si,car);

--===================================main-end


--===================================enviroment
MODULE Simulate(car)
	VAR
		x:{0,1,2,3,4};
		y:{0,1,2};
		tar_x:{0,1,2,3,4};
		tar_y:{0,1,2};
		car_angle:{0,1,2,3,4,5,6,7};
	DEFINE
		--a circle in x,y cordinary
		road:=[[0,0],[0,1],[0,2],[1,2],[2,2],[3,2],[4,2],[4,1],[4,0],[3,0],[2,0],[1,0]];
		carport:=[[1,1],[2,1],[3,1]];
		carport_car:=[1,1,0];
		--[1] how to represent?
		carport_type:={isLine};
		--barrier:=[[-1,-1]];
		barrier:=0;
		cross:=[[0,0],[0,2],[4,2],[4,0]];
		
		position:=[x,y];
		tar_pos:=[tar_x,tar_y];
		
	ASSIGN
		init(x):=0;
		init(y):=0;
		init(car_angle):=2;
		
		next(x):=
		case
			(car.car_speed=1)&(car.car_angle=0):x+1;
			(car.car_speed=1)&(car.car_angle=4):x+(-1);
			TRUE:x;
		esac;
		
		next(y):=
		case
			(car.car_speed=1)&(car.car_angle=2):y+1;
			(car.car_speed=1)&(car.car_angle=6):y+(-1);
		esac;
		
		next(car_angle):=
		case
			(car.car_speed=1)&(car.car_angle=2)&(car.car_wheelAngle=1):0;
			(car.car_speed=1)&(car.car_angle=0)&(car.car_wheelAngle=1):6;
			(car.car_speed=1)&(car.car_angle=6)&(car.car_wheelAngle=1):4;
			(car.car_speed=1)&(car.car_angle=4)&(car.car_wheelAngle=1):2;
			TRUE:car_angle;
		esac;
		

MODULE Car(actuator)
	VAR
		car_speed:{-1,0,1};
		car_wheelAngle:{-1,0,1};
	DEFINE
		
		status:=[car_speed,car_wheelAngle];

	ASSIGN
		init(car_speed):=0;
		init(car_wheelAngle):=0;
		
		next(car_wheelAngle):=actuator[0];
		next(car_speed):=
		case
			car_brake=1:0;
			actuator[2]=1:0;
			TRUE:actuator[1];
			
		next(car_brake):=actuator[2];
		next(car_gear):=actuator[3];

MODULE CarIner(car,simulate)
	VAR
		--front or back
		sensor_speed:WheelSpeed(car.car_speed);
		sensor_wheelAngle:WheelAngle(car.car_wheelAngle);
		sensor_GPS:GPS(simulate.position);
		sensor_campass:Campass(simulate.car_angle);
	DEFINE
		car_speed:=sensor_speed.out;
		car_wheelAngle:=sensor_wheelAngle.out;
		car_position:=sensor_GPS.out;
		car_angle:=sensor_campass.out;

--===================================ats
MODULE ATS(simulate,car)
	VAR
		sensor_ultrasonic:Ultrasonic(car.position,simulate);
		sensor_around:AroundCamera(car.position,simulate);
		sensor_eye:DoubleEyeCamera(car.position,simulate);

		can:CanBus(cpt_sys.can_out,car_info);
		cpt_sys:ComputeSystem(sensor_ultrasonic.out,sensor_around.around_ports,sensor_eye.out,can.get,simulate);
		ctl_sys:ControlSystem(can.out);
		car_info:CarIner(car);

		actuator_steerWheel:SteerWheel(ctl_sys.steerWheel);
		actuator_engine:Engine(ctl_sys.engine);
		actuator_brake:Brake(ctl_sys.brake);
		actuator_gear:Gear(ctl_sys.gear);


	DEFINE
		actuator:=[actuator_steerWheel.out,actuator_engine.out,actuator_brake.out,actuator_gear.out];

--===================================ats-end
--sensor
--===================================
MODULE Ultrasonic(car_position,simulate)
	DEFINE
		out:=simulate.barrier;

MODULE AroundCamera(car_position,simulate)
	DEFINE
		x:=car_position[0];
		y:=car_position[1];
		around_port:=[[x+1,y],[x+1,y+1],[x,y+1],[x+(-1),y+1],[x+(-1),y],[x+(-1),y+(-1)],[x,y+(-1)],[x+1,y+(-1)]];
		position:=car_position;

MODULE DoubleEyeCamera(car_position,simulate)
	VAR
		--front point
		x0:{0,1,2,3,4};
		y0:{0,1,2};
	DEFINE
		x:=car_position[0];
		y:=car_position[1];
		car_angle:=simulate.car_angle;
		out:=[x0,y0];
	ASSIGN
		init(x0):=x;
		init(y0):=y+1;

		next(x0):=
		case
			car_angle=0:x+1;
			car_angle=2:x;
			car_angle=4:x+(-1);
			car_angle=6:x;
			TRUE:x0;
		esac;

		next(y0):=
		case
			car_angle=0:y;
			car_angle=2:y+1;
			car_angle=4:y;
			car_angle=6:y+(-1);
			TRUE:y0;
		esac;


MODULE WheelSpeed(input)
	DEFINE
		out:=input;

MODULE WheelAngle(input)
	DEFINE
		out:=input;

MODULE GPS(input)
	DEFINE
		out:=input;

MODULE Campass(input)
	DEFINE
		out:=input;
--===================================

--===================================
MODULE ComputeSystem(ultrasonic_signal,around_signal,eye_signal,can_in,simulate)
	VAR
		board_TX1:TX1(eye_signal);
		board_I2C:I2C(board_TX1.I2C_out);
		board_Rcar:Rcar(ultrasonic_signal,around_signal,board_I2C.out,can_in,simulate);
	DEFINE
		can_out:=board_Rcar.can_out;
--===================================

--===================================
MODULE ControlSystem(input)
	DEFINE
		out:=input;
		steerWheel:=input[0];
		engine:=input[1];
		brake:=input[2];
		gear:=input[3];

--===================================
--bus
--===================================
MODULE I2C(input)
	DEFINE
		out:=input;

MODULE CanBus(input,car_info)
	DEFINE
		out:=input;
		get:=car_info;

--===================================
--===================================
MODULE Rcar(ultrasonic_signal,around_signal,I2C_input,can_in,simulate)
	VAR
		ultrasonic:comp_ultrasonic(ultrasonic_signal);
		--around detect algorithm
		around:comp_around(around_signal,simulate);
		stop:comp_stop(ultrasonic.out,can_in,plan.flag[1]);
		plan:comp_plan(ultrasonic.out,around.out,I2C_input,can_in);
		plan_ctl:comp_ctl(back_path.trace,can_in);
		--I2C_input=eye_signal

		cmd_brake:{1,0};

	DEFINE
		can_out:=[cmd_angle,cmd_speed,cmd_brake,cmd_gear];
		flag:=plan.flag;
		cmd_speed:=plan_ctl.cmd_speed;
		--[3]
		cmd_angle:=plan_ctl.cmd_angle;
		cmd_gear:=(flag[0]=0)?0:plan_ctl.cmd_gear;
	ASSIGN
		init(cmd_brake):=0;

		next(cmd_brake):=
		case
			(stop.isStop=2):1;
			TRUE:cmd_brake;
		esac;

MODULE TX1(input_signal)
	VAR
		target:comp_double(input_signal);

	DEFINE
		I2C_out:=target.out;
--===================================
--compute
--===================================
MODULE comp_plan(ultrasonic_info,around_valuePort,eye_info,can_in)
	VAR
		--stop enviroment
		garage:{0,1};
		line:{0,1};
		gear:{-1,0,1};

		--if stop when reach end point
		plan_stop:{0,1};

		--if follow the road line
		followLine:{0,1};
		tinyAdjust:{-1,0,1};
		garage_type:{isLine,isGarage};

		back_path:comp_road(around_valuePort,can_in);
		
	DEFINE
		--[3]the enviroment value form last version around_info
		around_info:=[1,isLine];
		--Ve:=can_in[0];
		trace:=back_path.trace;
		tar_pos:=back_path.plan_point;
		Xe:=tar_pos[0];
		Ye:=tar_pos[1];
		car_position:=can_in.car_position;
		X:=car_position[0];
		Y:=car_position[1];
		parallel:=around_info[0];
		flag:=[gear,plan_stop,followLine,parallel,tinyAdjust];

		--compute the cmd to ctl;
	ASSIGN
		init(gear):=0;
		init(plan_stop):=0;
		init(followLine):=0;
		init(tinyAdjust):=0;
		init(garage):=0;
		init(line):=0;

		next(garage):=
		case
			around_info[1]=isGarage:1;
			TRUE:garage;
		esac;

		next(line):=
		case
			around_info[1]=isLine:1;
			TRUE:line;
		esac;

		next(gear):=
		case
			ultrasonic_info=1:0;
			(Xe=X)&(Ye=Y):0;
			TRUE:gear;
		esac;

		next(plan_stop):=
		case
			ultrasonic_info=1:1;
			(Xe=X)&(Ye=Y):1;
			TRUE:plan_stop;
		esac;

		next(followLine):=
		case
			(line!=0)&(garage!=0):1;
			TRUE:0;
		esac;

		next(tinyAdjust):=
		case
			(ultrasonic_info=1)|(parallel=0):1;
			TRUE:tinyAdjust;
		esac;

MODULE comp_ctl(trace,can_in)
	VAR
		PID1:runDis();
		angle:runAngle();
		curve:getCurve();
		PID2:cross();

		cmd_angle:{-1,0,1};
		cmd_gear:{-1,0,1};
		cmd_speed:{-1,0,1};
		cmd_stop:{0,1};
	DEFINE
		--forecase_dis:=1;
		--PID:=[PID1,PID2];

		car_position:=can_in.car_position;
		car_angle:=can_in.car_angle;
		plan_point:=trace[1];

		dx:=car_position[0]+(-plan_point[0]);
		dy:=car_position[1]+(-plan_point[1]);
		control:=[cmd_speed,cmd_angle,cmd_gear];

	ASSIGN
		init(cmd_angle):=0;
		init(cmd_speed):=0;
		init(cmd_gear):=0;
		init(cmd_stop):=0;
		next(cmd_gear):=
		case
			(car_angle=0)&(dx=1&dy=1):-1;
			(car_angle=4)&(dx=-1&dy=-1):-1;
			(car_angle=0)&(dx>1):1;
			(car_angle=4)&(dx<1):1;
			(car_angle=2|6):1;
			TRUE:cmd_gear;
		esac;

		next(cmd_angle):=
		case
			(car_angle=0)&(dx=1&dy=1):1;
			TRUE:cmd_angle;
		esac;

		next(cmd_stop):=
		case
			(car_angle=0)&(dx=1):1;
			(car_angle=4)&(dx=-1):1;
			TRUE:cmd_stop;
		esac;

		--[4]can?
		next(cmd_speed):=next(cmd_gear);

MODULE runDis()

MODULE runAngle()

MODULE getCurve()

MODULE cross()

MODULE comp_road(around_valuePort,can_in)
	DEFINE
		no_port:=[-1,-1];
		plan_point:=
		case
			around_valuePort[0]!=-1:around_valuePort[0];
			around_valuePort[1]!=-1:around_valuePort[1];
			around_valuePort[2]!=-1:around_valuePort[2];
			TRUE:no_port;
		esac;
		
		trace:=[can_in.car_position,plan_point];

MODULE comp_stop(ultrasonic_info,can_in,plan_stop)
	VAR
		-- state flag, 0 normal, 1 speed down, 2 stop
		isStop:{0,1,2};
	DEFINE
		--the target speed;
		velo:=can_in.car_speed;
		packetStop:=[velo,isStop];

	ASSIGN
		init(isStop):=0;

		next(isStop):=
		case
			(ultrasonic_info=1):2;
			TRUE:isStop;
		esac;


MODULE comp_ultrasonic(input)
	DEFINE
		out:=input;

MODULE comp_double(input)
	DEFINE
		out:=input;

MODULE comp_around(around_signal,simulate)
	VAR
		i:{0,1,2,3,4,5,6,7};
		j:{0,1,2};

	DEFINE
		--light:input[0];
		--scene:input[1];
		ports:=around_signal;
		carport:=simulate.carport;
		carport_car:=simulate.carport_car;
		out:=[valuePort1,valuePort2,valuePort3];

		--[2] integer can't be case, replace port itself?
		valuePort1:=
		case
			(ports[0]=carport[0])&(carport_car[0]=0):ports[0];
			(ports[1]=carport[0])&(carport_car[0]=0):ports[1];
			(ports[2]=carport[0])&(carport_car[0]=0):ports[2];
			(ports[3]=carport[0])&(carport_car[0]=0):ports[3];
			(ports[4]=carport[0])&(carport_car[0]=0):ports[4];
			(ports[5]=carport[0])&(carport_car[0]=0):ports[5];
			(ports[6]=carport[0])&(carport_car[0]=0):ports[6];
			(ports[7]=carport[0])&(carport_car[0]=0):ports[7];
			TRUE:-1;
		esac;

		valuePort2:=
		case
			(ports[0]=carport[1])&(carport_car[1]=0):ports[0];
			(ports[1]=carport[1])&(carport_car[1]=0):ports[1];
			(ports[2]=carport[1])&(carport_car[1]=0):ports[2];
			(ports[3]=carport[1])&(carport_car[1]=0):ports[3];
			(ports[4]=carport[1])&(carport_car[1]=0):ports[4];
			(ports[5]=carport[1])&(carport_car[1]=0):ports[5];
			(ports[6]=carport[1])&(carport_car[1]=0):ports[6];
			(ports[7]=carport[1])&(carport_car[1]=0):ports[7];
			TRUE:-1;
		esac;

		valuePort3:=
		case
			(ports[0]=carport[2])&(carport_car[2]=0):ports[0];
			(ports[1]=carport[2])&(carport_car[2]=0):ports[1];
			(ports[2]=carport[2])&(carport_car[2]=0):ports[2];
			(ports[3]=carport[2])&(carport_car[2]=0):ports[3];
			(ports[4]=carport[2])&(carport_car[2]=0):ports[4];
			(ports[5]=carport[2])&(carport_car[2]=0):ports[5];
			(ports[6]=carport[2])&(carport_car[2]=0):ports[6];
			(ports[7]=carport[2])&(carport_car[2]=0):ports[7];
			TRUE:-1;
		esac;
--===================================
--actuator
--===================================
MODULE SteerWheel(input)
	DEFINE
		out:=input;

MODULE Engine(input)
	DEFINE
		out:=input;

MODULE Brake(input)
	DEFINE
		out:=input;

MODULE Gear(input)
	DEFINE
		out:=input;

--===================================

/--
1.位置信息暂时由GPS单独处理
2.stop模块中的减速尚未使用

黑盒部分
3.trace暂时以车与目标坐标构成
--/

/-- TODO
[1]Simulate
	represent state in define
	if module can be param?yes
[2]comp_around
	ports
[3]plan_action:around
	sensor around deal with enviroment?
[4]next=next?
--/

/--Do to

speed or wheel speed
can_in change to module not array anymore,but later undone;

--/
